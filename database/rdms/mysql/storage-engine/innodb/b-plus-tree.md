# B+Tree Index

- 深入探索MySQL索引策略 https://mp.weixin.qq.com/s/XpukKx9Ovl4bqil8cNDP0g

### 没有索引时的查找

1. 在一个页中查找（数据很少）
    
    a. 主键为搜索条件
    
    二分查找找到对应的槽，然后遍历槽所在组里面的记录（单向链表），对比条件
    
    b. 非主键为搜索条件
    
    依次遍历单向链表中的每条记录，对比条件
    
2. 在多个页中查找（数据多）
    
    先遍历所有的页（双向链表），然后在走上面的单页逻辑
    

### B+TREE索引设计

给页目录项也按照记录数据存放在页中，但是存放目录项的页和存放记录的页格式稍微不一样

1. 存放记录的页格式
    
    record_type=0
    
    next_record指针
    
    列1数据
    
    ...
    
    列n数据
    
2. 存放目录项页的格式（当数据特别多，页目录项可递归再生成页目录项的目录项）
    
    record_type=1
    
    next 指针
    
    key 主键
    
    page_no 页号
    
    PS：多个存放记录数据的页之间用双向链表连接，存放记录数据的页内部多个记录数据之间用单链表链接。


### B Tree 和 B+ Treei 树的区别
1.B树的每个节点都存储了key和data，而B+树的data存储在叶子节点上。
- B+树非叶子节点仅存储key不存储data，这样一个节点就可以存储更多的key，可以使得B+树相对B树来说更矮（IO次数就是树的高度），所以与磁盘交换的IO操作次数更少。

2.B+树所有叶子节点构成一个 有序链表，按主键排序来遍历全部记录，能更好支持范围查找。
- 由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

3.B+树所有的查询都要从根节点查找到叶子节点，查询性更稳定；而B树，每个节点都可能查找到数据，需要在叶子节点和内部节点不停的往返移动，所以不稳定。


### InnoDB 索引的类型

**聚簇索引（索引和数据存在一个文件中）**

叶子结点存的是完整的数据记录

**二级索引**

叶子结点记录数据页的结构只存索引列的值+主键，然后再回到聚簇索引中查找具体的记录（回表操作）

目录项中页的结构变成了索引列的值+主键+页号

回表操作：

1. 省空间，如果每创建一个索引，叶子结点就存完整的表数据，太废空间
2. 如果有大量回表操作，则随机I/O变多，性能变差

**联合索引（二级索引的一种）**

叶子结点记录数据页的结构只存（联合索引列的值 c1, c2）+（主键）

目录项中页的结构变成了（联合索引列的值 c1, c2）+（主键）+（页号）

PS：

回表操作多的话，会有大量随机IO，会很耗性能。

为避免回表操作，可以使用”覆盖索引“概念，即索引中已经包含需要查询的列的数据

### MyISAM索引

索引和数据分开成两个文件

MyISAM中建立的单列索引全都是InnoDB中的二级索引概念（即需要回表去查具体数据）

### 索引其他概念

与书籍目录的作用相似

在索引中找对应的值，根据匹配索引找到对应的数据行

1. 对性能的影响
    
    优点：
    
    减少扫描数据量
    
    避免排序和临时表
    
    随机I/O → 顺序I/O
    
    缺点：
    
    随着占用磁盘空间变大，查询速度变快，写速度变慢
    
    PS：非常小的表不需要用索引
    
2. 索引类型
    
    普通索引：无约束
    
    唯一索引：唯一约束
    
    主键索引：特殊唯一约束、不允许有空值
    
    组合索引：多个列组合在一起的索引
    
    外键索引：只有InnoDB有，保证数据一致性、完整性；实现级联操作（基本不用：使用逻辑代替）
    
    全文索引：只有MyISAM有，只能对英文索引（基本不用）
    

### 索引创建原则

0. 只为用于搜索、排序、分组的列创建索引

1. 最适合索引的列是在 where 子句中的列，而不是出现在 select 关键字后的列
2. 索引基数越大，索引效率越好
3. 对字符串进行索引，应该制定一个前缀长度，可节省空间
4. 根据情况创建符合索引，提高效率（符合索引的前缀原则）
5. 避免过多索引，占用磁盘空间，降低写效率
6. 主键选择较短数据类型，提升查询效率

### 索引使用原则

1. 作用关键词 where, order by, group by
2. 符合索引遵循前缀原则
3. like查询，%不能在前，若要在前可使用全文索引
4. where column is null 可以使用索引
5. 若使用索引比全表索引慢，MySQL会自动放弃索引
6. 列类型是字符串，查询时一定要给值加字符串，否则索引失效

### 索引模型底层的数据类型

1. 哈希表
2. 有序数组
3. 搜索树

总结：

1.索引的作用：提高数据查询效率

2.常见索引模型：哈希表、有序数组、搜索树

3.哈希表：键 - 值(key - value)。

4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置

5.哈希冲突的处理办法：链表

6.哈希表适用场景：只有等值查询的场景

7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))

8.有序数组查询效率高，更新效率低

9.有序数组的适用场景：静态存储引擎。

10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子

11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))

12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树

13.InnoDB中的索引模型：B+Tree

14.索引类型：主键索引、非主键索引

主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)

15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)

16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。

17.从性能和存储空间方面考量，自增主键往往是更合理的选择。

思考题：

如果删除，新建主键索引，会同时去修改普通索引对应的主键索引，性能消耗比较大。

删除重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务。

### 索引高级概念

回表：从普通索引树回到主键索引树搜索的过程，我们称为回表

由于查询结果所需要的数据只在主键索引上有，所以不得不回表。

覆盖索引：当查询里面普通索引 已经“覆盖了”我们的查询需求，不需要再去主键索引树搜索，那么我们称为覆盖索引。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

联合索引：

B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。

在建立联合索引的时候，如何安排索引内的字段顺序。

评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

索引下推：
