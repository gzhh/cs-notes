# 事务并发执行时遇到的一致性问题 

### 脏写、脏读、不可重复读、幻读

**P0脏写 Dirty Write** 一个事务修改了另一个未提交事务修改过的数据

**P1脏读 Dirty Read** 一个事务读到了另一个未提交事务修改过的数据

当数据库中一个事务A正在修改一个数据但是还未提交或者回滚，

另一个事务B 来读取了修改后的内容并且使用了，

之后事务A提交了，此时就引起了脏读。

此情况仅会发生在： 读未提交的的隔离级别.

❎ **P2不可重复读** Non-Repeatable-Read 一个事务修改了另一个未提交事务读取的数据（模糊读 Fuzzy Read）

在一个事务A中多次操作数据，在事务操作过程中(未最终提交)，

事务B也才做了处理，并且该值发生了改变，这时候就会导致A在事务操作

的时候，发现数据与第一次不一样了。 就是不可重复读。

此情况仅会发生在：读未提交、读提交的隔离级别.

❎ **P3幻读 Phantom** 如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写了一些符合那些搜索条件的记录

### 导致一致性问题的严重性

脏写 > 脏读 > 不可重复读 > 幻读

不同隔离基本可以发生的现象
| 隔离级别 | 脏写 | 脏读 | 不可重复读 | 幻读 | 备注 |
|---|---|---|---|---|---|
| READ UNCOMMITTED | 不可能 | 可能 | 可能| 可能 |  |
| READ COMMITTED | 不可能 | 不可能 | 可能 | 可能 |  |
| REAPEATABLE READ | 不可能 | 不可能 | 不可能 | 可能 | 解决幻读的方法：1.MVCC 2.加锁 |
| SERIALIZABLE | 不可能 | 不可能 | 不可能 | 不可能 |  |


PS：

因为脏写对一致性影响太严重了，无论哪种隔离级别，都不允许脏写的情况发生。

### 其他

一个事务按相同的查询条件重新读取以前检索过的数据，

却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。

幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.

一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。

此情况会回发生在：读未提交、读提交、可重复读的隔离级别.

脏读：当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。

举例：事务A开启 update tb set name='zhangshan' where k=20 提交之前， 事务B开始了 去拿 k=20的name值，提交。然后这时候事务A 提交事务 发生了错误，进行回滚。所以B取得数据是和现版本不一致的。

不可重复读：当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。

幻读：当前事务读第一次取到的数据比后来读取到数据条目少。

举例：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。

不可重复读针对的是update或delete，幻读针对的insert。
