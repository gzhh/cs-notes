# Transaction

## 简介

在事务对表中的记录进行改动时，才会为这个事务分配一个事务id。事务id值是一个递增的数字。先被分配id的事务得到的是较小的事务id，后被分配id的事务得到的是较大的事务id。未被分配事务id的事务id默认是0。聚簇索引记录中有一个trx_id隐藏列，它代表对这个聚簇索引记录进行改动的语句所在的事务对应的事务id


## 事务的持久性

如果一个事务执行了一半的时候服务器突然崩溃，假如这个事务执行过程中所写的redo log日志尚未刷新到磁盘，也就是还停留在内存log buffer中，那么就相当于什么都没做。

假如这些redo log日志都已经刷新到磁盘中，那么在下次开机重启时回根据这些redo log日志把页面恢复过来，但是这就造成了一个事务处于只执行一半的状态。

这些执行了一半的事务对页面所做的修改都会被撤销，这就是undo log日志所做的。

### redo log

在系统因崩溃而重启时需要按事务修改操作的步骤将数据重新更新数据页，这个记录操作步骤的内容就称为重做日志（redo log）

事务提交时只将执行过程中产生的redo日志刷新到磁盘，而不是将所有修改过的页面都刷新到磁盘。这样做的好处

- redo日志占用空间小
- redo日志是顺序写入磁盘的


### undo log

把为了回滚操作而记录的日志称为撤销日志（undo log）

**事务id**

trx_id默认自增，在聚簇索引中作为隐藏列记录，与隐藏的row_id类似


## 事务隔离级别和MVCC
**事务并发执行时碰到的一致性问题**

1. 脏写 Dirty Write
    
    一个事务修改了另一个未提交事务修改过的数据。
    
2. 脏读 Dirty Read
    
    广义上解释是一个事务读到了另一个未提交事务修改过的数据。
    
3. 不可重复读 Non-Repeatable Read
    
    广义上解释是一个事务修改了另一个未提交事务读取的数据。
    
4. 幻读 Phantom
    
    一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录。
    

SQL **隔离级别**

1. READ UNCOMMITTED 未提交读
2. READ COMMITTED 已提交读
3. REPEATABLE READ 可重复读
4. SERIALIZABLE 序列化

**不同隔离级别可发生的现象**

| 隔离级别 | 脏写 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- | --- |
| READ UNCOMMITTED
未提交读 | 不可能 | 可能 | 可能 | 可能 |
| READ COMMITTED
已提交读 | 不可能 | 不可能 | 可能 | 可能 |
| REPEATABLE READ
可重复读 | 不可能 | 不可能 | 不可能 | 可能 |
| SERIALIZABLE
序列化 | 不可能 | 不可能 | 不可能 | 不可能 |

**MVCC 多版本并发控制**

- trx_id
- roll_pointer

多个事务并发执行时，每次更新某条记录后，都会将旧值放到一条undo日志中（就算是该记录的一个旧版本）。随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，这个链表称为版本链。

版本链的头节点就是当前记录的最新值。另外每个版本中还包含生成该版本时对应的事务id。之后会利用这个记录的版本链来控制并发事务访问相同记录时的行为，我们把这种机制称为 MVCC
