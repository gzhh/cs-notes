# Lock

## 事务与锁
**并发事务带来问题的两种方式**

1. 读
    
    无问题
    
2. 写写
    
    问题
    
    - 脏读
    
    解决办法
    
    - 加锁
3. 读-写 或 写-读
    
    问题
    
    - 脏读
    - 不可重复读
    - 幻读
    
    解决办法
    
    1. 读操作使用 MVCC，写操作进行加锁
    2. 读、写操作都采用加锁

**共享锁与独占锁（行级锁）**

- 共享锁 Shared Lock（S锁）在事务要读取一条记录时，需要先获取该记录的 S 锁。
- 独占锁 Exclusive Lock（X锁，也称拍他锁）在事务要改动一条记录时，需要先获取该记录的 X 锁。

S 锁与 X 锁的兼容关系

| 兼容性 | X锁 | S锁 |
| --- | --- | --- |
| X锁 | 不兼容 | 不兼容 |
| S锁 | 不兼容 | 兼容 |

**锁定读（行级锁）**

在读取记录前就为该记录加锁的方式称为锁定读（Locking Read）

1. 对读取的记录加S锁
    
    select ... lock in share mode;
    
2. 对读取的记录加X锁
    
    select ... for update;
    

### 多粒度锁

前面提到的锁都是针对记录的，可将其称为行级锁或行锁。

也可以对表加S锁和X锁。

**意向锁Intention Lock（表级锁）**

- 意向共享锁 intention shared lock
    
    简称 IS 锁，当事务准备在某条记录上加 S 锁时，需要现在表级别加一个 IS 锁。
    
- 意向独占锁 intention exclusive lock
    
    简称 IX 锁，当事务准备在某条记录上加 X 锁时，需要现在表级别加一个 IX 锁。
    

表级别锁的兼容性

| 兼容性 | X | IX | S | IS |
| --- | --- | --- | --- | --- |
| X | 不兼容 | 不兼容 | 不兼容 | 不兼容 |
| IX | 不兼容 | 兼容 | 不兼容 | 兼容 |
| S | 不兼容 | 不兼容 | 兼容 | 兼容 |
| IS | 不兼容 | 兼容 | 兼容 | 兼容 |


## InnoDb中的锁
InnoDB既支持表级锁，也支持行级锁。表级锁粒度粗，占用资源少，不过表级锁对一个表中所有的记录都加锁，所以性能差。行级锁粒度细，可以实现更精准的并发控制，但是占用资源较多。

**InnoDB中的表级锁**

1. 表级别 S锁、X锁
    
    一般手动用的不多
    
    操作
    
    - 加 S 锁
        
        select ... lock in share mode
        
    - 加 X 锁
        
        select ... for update
        

**InnoDB中的行级锁**

1. Record Lock 记录锁，只对记录本身加锁
2. Gap Lock 锁住记录前的间隙，防止别的事务向该间隙插入新纪录
3. ...

**分析死锁**

show engine innodb status
