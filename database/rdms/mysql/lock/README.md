# Lock

目的：解决并发访问

锁的种类：全局锁、表级锁、行锁

### 全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

全局锁的典型使用场景是，做全库逻辑备份（备份一般都会在备库上执行，这时主库同步过来的binlog会延迟接收）

### 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

表锁一般是在数据库引擎不支持行锁的时候才会被用到的

### 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。InnoDB 是支持行锁的。

行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

使用事务的技巧：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。我给你举个例子。

死锁和死锁检测：

事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态

当出现死锁以后，有两种策略：

一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。

另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

死锁检测好烦大量CPU资源：怎么解决由这种热点行更新导致的性能问题呢

1. 临时把死锁检测关掉
2. 控制并发度（在mysql上一层做并发控制）

### 锁粒度(级别)

**表级锁（MyISAM、InnoDB）**

锁粒度大，并发度最低；开销小、加锁快；不会出现死锁；

**行级锁（InnoDB默认）**

锁粒度最小，并发度最高；开销大，加锁慢；会出现死锁；

### 锁类型

**行级锁中包含共享锁与排他锁**

共享锁 shard lock (S Lock 又称读锁)

多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。

拍他锁 exclusive lock (X Lock 又称写锁)

一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。

加S锁

select ... lock in share mode

加X锁

select ... for update

**其他锁**

https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html

### 锁结构

表锁特有结构：

表信息

其他信息

行锁特有结构：

Space ID

Page Number

n_bits

### 查看事务加锁情况

**使用information_schema**

select * from information_schema.INNODB_TRX\G;

- trx_table_locked
- trx_row_locked

select * from information_schema.INNODB_LOCKS;

select * from information_schema.INNODB_LOCK_WAITS;

**使用show engine innodb status**

show engine innodb status\G;

### 死锁

给资源加锁时可能会出现死锁

innodb有死锁检测机制，当出现死锁时，会选择较小的事务进行回滚操作

### 悲观锁与乐观锁

```markdown
### select for update的使用场景
如果遇到存在高并发并且对于数据的准确性很有要求的场景，是需要了解和使用for update的。
for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。
在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。

### 数据一致性场景
**悲观锁方案**
每次获取商品时，对该商品加排他锁。也就是在用户A获取获取 id=1 的商品信息时对该行记录加锁，期间其他用户阻塞等待访问该记录。悲观锁适合写入频繁的场景。

**乐观锁方案（TODO 概念不对）**
每次获取商品时，不对该商品加锁。在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新，反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。乐观锁适合读取频繁的场景。

如果我们需要设计一个商城系统，该选择以上的哪种方案呢？
查询商品的频率比下单支付的频次高，基于以上我可能会优先考虑第二种方案（当然还有其他的方案，这里只考虑以上两种方案）。

**乐观锁的实现原理：**
1. 一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。
2. 另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。
3. 第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。

### 行锁与表锁
InnoDB默认是行级别的锁，当有明确指定的主键时候，是行级锁。否则是表级别。

for update的注意点
for update 仅适用于InnoDB，并且必须开启事务，在begin与commit之间才生效。
要测试for update的锁表情况，可以利用MySQL的Command Mode，开启二个视窗来做测试。

### 总结
1、InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
2、由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。
3、当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
4、即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。
5、检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。

### 参考
https://stackoverflow.com/questions/6066205/when-using-mysqls-for-update-locking-what-is-exactly-locked
https://stackoverflow.com/questions/22242081/select-for-update-holding-entire-table-in-mysql-rather-than-row-by-row
https://zhuanlan.zhihu.com/p/143866444
```

