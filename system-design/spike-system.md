# 秒杀系统

## 介绍
在某一时间段，有大量的用户下单购买某件商品，对应的系统需要在高并发情况下提供正常的、稳定的服务，那么这样的系统我们一般可以称之为秒杀系统。

### 秒杀场景真实用例
- 春节期间 12306 官网某一固定时间点出票，大量乘客进行线上下单购票
- 苹果新款手机某一固定时间首次发售，大量用户进行线上下单购买

### 秒杀系统几个核心的阶段
- 生成订单
- 扣件库存
- 用户支付

### 秒杀系统需要解决的几个核心问题
- 商品不超卖
- 商品不少卖
- 每件商品都必须支付才购买有效
- 保证系统的高并发处理能力


## 水平扩容负载均衡
可以使用水平扩容来处理短时间内的大量用户请求，一般在 API Gateway 网关层面使用负载均衡器将请求按一定规则均匀分配到各个业务节点服务器。

## 异步化
因为生成订单操作一般比较耗时，我们可以将这一步骤异步化，可以使用 MQ 来处理

## 库存扣件方案
### 下单减库存
流程：请求 -> 创建订单（扣库存）-> 支付

问题：
- 存在用户恶意下单且不支付的情况，从而导致库存变少，出现“少卖”
- 避免不了扣库存时创建订单存储到数据库磁盘的耗时操作

### 支付减库存
流程：请求 -> 创建订单 ->  支付（扣库存）

问题：
- 可能会出现用户下完单后，再去支付时出现失败的情况，因为库存可能被其他用户的支付操作扣减完了，出现“超卖”
- 不能避免并发读写数据库磁盘 I/O 操作

### 预扣库存
流程：请求 -> 扣减库存 -> 通过 MQ 异步创建订单 -> 指定时间内进行支付完成流程；或超过支付时间取消订单并返还库存完成流程

### 针对预扣库存方案的优化
- 本地扣减库存（本地预存）
  - 将所有库存均匀分配给各个服务节点，存储在服务节点的内存中，扣减库存通过内存直接操作，从而减少高并发数据库磁盘 I/O 操作
- 远程统一扣减库存（Redis 总控，使用分布式锁）
  - 为避免服务节点出现异常宕机情况，导致出现对应服务节点的库存卖不出去这种情况，需引入统一扣减库存逻辑，一般使用 Redis 存储统一库存
  - Redis 初始化时存储统一库存总量，后续如果服务节点有扣件完库存并生成相应的订单后，那么请求 Redis 减掉相应库存
  - 因为服务节点会出现宕机情况导致还有库存剩余，那么我们需要在每个服务节点再分配额外的 buffer 库存，用于避免这种情况
    - buffer 大小需要控制好，buffer 太小服务节点故障时可能还是会出现少卖，太大则会增加与 Redis 的网络通信 I/O

## 参考
- [秒杀系统的艺术](https://juejin.cn/post/6844903949632274445)
- https://v2ex.com/t/703857
- [库存扣减](https://maimai.cn/web/gossip_detail?encode_id=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlZ2lkIjoiODA1NjQ4NWM1YTI3NDQ5N2EwZDMzMDY2OTNlNjA2NDEiLCJpZCI6MzEwNzUzNDUsInUiOjE5NDEzNTc0MH0.hDGQ5O6BEIZyUwF-mi5YOOrcssMxDTPOTWc-TMEs8Ng)
