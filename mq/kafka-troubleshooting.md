# Kafka 常见问题
## 一、性能问题

前提，kafka采用的是传统的拉模式，即producer推消息到broker，consumer从broker拉消息，该模式如果consumer处理消费速度跟不上producer推送的速度时，broker会有消息堆积。

因为另一种推模式，即producer直接将消息推到consumer，当consumer处理消息的速度远远跟不上producer推送的速度，那么很可能就consumer就直接崩溃。

### 消费

消费者对topic的订阅

客户端的消费者订阅了topic后，如果是单个消费者，那么消费者会顺序消费这些topic分区中的数据，如果是创建了消费组有多个消费者,那么kafak的服务端将这些topic平均分配给每个消费者。比如有2个topic,每个topic有2个分区，总共有4个分区，如果一个消费组开了四个消费者线程，那么每个消费者将被分配一个分区进行消费。一般建议是一个消费组里的消费者的个数与订阅的topic的总分区数相等，这样可以达到最高的吞吐量。如果消费者的个数大于订阅的topic的总分区，那么多出的消费者将分配不到topic的分区，等于是白白创建了一个消费者线程，浪费资源。

## 二、消息丢失

消息丢失得分两种情况 ： 生产者 和 消费者 都有可能因处理不当导致消息丢失的情况

### 发送端消息丢失

acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。大数据统计报表场景，对性能要求很高，对数据丢失不敏感的情况可以用这种。
acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。
acks=-1或all： 这意味着leader需要等待所有备份(min.insync.replicas配置的备份个数)都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。当然了如果min.insync.replicas配置的是1则也可能丢消息，跟acks=1情况类似。

### 消费端消息丢失

如果消费这边配置的是自动提交，万一消费到数据还没处理完，就自动提交offset了，但是此时你consumer直接宕机了，未处理完的数据丢失了，下次也消费不到了。


## 三、重复消费

## 四、ACK 机制

kafka默认是自动ACK，自动提交offset

### acks

producer → broker

- 0 producer不等待broker的大幅，消息就立即发往socket buffer
- 1 等待leader broker记录消息（默认）
- all 等待所有broker记录消息，保证消息不会丢失

### 手动ACK，手动提交offset

broker → consumer

手动 ACK 模式，由业务逻辑控制提交偏移量。比如程序在消费时，有这种语义，特别异常情况下不确认 ack，也就是不提交偏移量，那么你只能使用手动 Ack 模式来做了。开启手动首先需要关闭自动提交，然后设置下 consumer 的消费模式

```
...ack-mode=manual
```

上面设置好后，在消费时，只需要在监听方法的入参加入 Acknowledgment 即可，执行到 ack.acknowledge() 代表提交了偏移量

### 问题

一、**消费者在消费消息的过程中，配置参数设置为不自动提交offset，在消费完数据之后如果不手动提交offset，那么在程序中和kafak中的数据会如何被处理呢?**

1.如果在消费kafka的数据过程中，一直没有提交offset，那么在此程序运行的过程中它不会重复消费。但是如果重启之后，就会重复消费之前没有提交offset的数据。

2.如果在消费的过程中有几条或者一批数据数据没有提交offset，后面其他的消息消费后正常提交offset，那么服务端会更新为消费后最新的offset，不会重新消费，就算重启程序也不会重新消费。

3.消费者如果没有提交offset，程序不会阻塞或者重复消费，除非在消费到这个你不想提交offset的消息时你尝试重新初始化一个客户端消费者，即可再次消费这个未提交offset的数据。因为客户端也记录了当前消费者的offset信息，所以程序会在每次消费了数据之后，自己记录offset，而手动提交到服务端的offset与这个并没有关系，所以程序会继续往下消费。在你重新初始化客户端消费者之后，会从服务端得到最新的offset信息记录到本地。所以说如果当前的消费的消息没有提交offset，此时在你重新初始化消费者之后，可得到这条未提交消息的offset,从此位置开始消费。

### 参考

- [http://bcxw.net/article/671.html](http://bcxw.net/article/671.html)
